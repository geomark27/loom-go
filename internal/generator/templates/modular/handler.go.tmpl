package users

import (
	"net/http"
	"strconv"

{{- if .UseHelpers}}
	"github.com/geomark27/loom-go/pkg/helpers"
{{- end}}
	"github.com/gin-gonic/gin"
)

// handler maneja las rutas HTTP del módulo users
type handler struct {
	service Service
{{- if .UseHelpers}}
	logger  helpers.Logger
{{- end}}
}

// NewHandler crea una nueva instancia del handler
func NewHandler(service Service) *handler {
	return &handler{
		service: service,
{{- if .UseHelpers}}
		logger:  helpers.NewLogger(),
{{- end}}
	}
}

// RegisterRoutes registra las rutas del módulo users
func (h *handler) RegisterRoutes(router *gin.RouterGroup) {
	users := router.Group("/users")
	{
		users.GET("", h.getAll)
		users.POST("", h.create)
		users.GET("/:id", h.getByID)
		users.PUT("/:id", h.update)
		users.DELETE("/:id", h.delete)
	}
}

// getAll obtiene todos los usuarios
func (h *handler) getAll(c *gin.Context) {
	users, err := h.service.GetAllUsers()
	if err != nil {
{{- if .UseHelpers}}
		h.logger.Error("Failed to get users", "error", err)
{{- end}}
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": "Error obteniendo usuarios",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data":    users,
		"count":   len(users),
		"status":  "success",
		"message": "Usuarios obtenidos exitosamente",
	})
}

// getByID obtiene un usuario por ID
func (h *handler) getByID(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": "ID de usuario inválido",
		})
		return
	}

	user, err := h.service.GetUserByID(id)
	if err != nil {
		if err == ErrUserNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"status":  "error",
				"message": "Usuario no encontrado",
			})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": "Error obteniendo usuario",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data":    user,
		"status":  "success",
		"message": "Usuario obtenido exitosamente",
	})
}

// create crea un nuevo usuario
func (h *handler) create(c *gin.Context) {
	var dto CreateUserDTO
	if err := c.ShouldBindJSON(&dto); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": "Datos de entrada inválidos",
			"error":   err.Error(),
		})
		return
	}

{{- if .UseHelpers}}
	// Validar DTO usando helpers
	if errors := helpers.ValidateStruct(dto); len(errors) > 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"status": "error",
			"errors": errors,
		})
		return
	}
{{- else}}
	// Validar DTO
	if err := dto.Validate(); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": err.Error(),
		})
		return
	}
{{- end}}

	user, err := h.service.CreateUser(dto)
	if err != nil {
		if err == ErrUserAlreadyExists {
			c.JSON(http.StatusConflict, gin.H{
				"status":  "error",
				"message": err.Error(),
			})
			return
		}
{{- if .UseHelpers}}
		h.logger.Error("Failed to create user", "error", err)
{{- end}}
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": "Error creando usuario",
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"data":    user,
		"status":  "success",
		"message": "Usuario creado exitosamente",
	})
}

// update actualiza un usuario existente
func (h *handler) update(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": "ID de usuario inválido",
		})
		return
	}

	var dto UpdateUserDTO
	if err := c.ShouldBindJSON(&dto); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": "Datos de entrada inválidos",
			"error":   err.Error(),
		})
		return
	}

	user, err := h.service.UpdateUser(id, dto)
	if err != nil {
		if err == ErrUserNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"status":  "error",
				"message": "Usuario no encontrado",
			})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": "Error actualizando usuario",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data":    user,
		"status":  "success",
		"message": "Usuario actualizado exitosamente",
	})
}

// delete elimina un usuario
func (h *handler) delete(c *gin.Context) {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"status":  "error",
			"message": "ID de usuario inválido",
		})
		return
	}

	if err := h.service.DeleteUser(id); err != nil {
		if err == ErrUserNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"status":  "error",
				"message": "Usuario no encontrado",
			})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"status":  "error",
			"message": "Error eliminando usuario",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"status":  "success",
		"message": "Usuario eliminado exitosamente",
	})
}
