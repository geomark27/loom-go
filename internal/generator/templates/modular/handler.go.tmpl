package users

import (
	"encoding/json"
	"net/http"
	"strconv"

{{- if .UseHelpers}}
	"github.com/geomark27/loom-go/pkg/helpers"
{{- end}}
	"github.com/gorilla/mux"
)

// handler maneja las rutas HTTP del módulo users
type handler struct {
	service Service
{{- if .UseHelpers}}
	logger  helpers.Logger
{{- end}}
}

// NewHandler crea una nueva instancia del handler
func NewHandler(service Service) *handler {
	return &handler{
		service: service,
{{- if .UseHelpers}}
		logger:  helpers.NewLogger(),
{{- end}}
	}
}

// RegisterRoutes registra las rutas del módulo users
func (h *handler) RegisterRoutes(router *mux.Router) {
	users := router.PathPrefix("/users").Subrouter()
	users.HandleFunc("", h.getAll).Methods("GET")
	users.HandleFunc("", h.create).Methods("POST")
	users.HandleFunc("/{id}", h.getByID).Methods("GET")
	users.HandleFunc("/{id}", h.update).Methods("PUT")
	users.HandleFunc("/{id}", h.delete).Methods("DELETE")
}

// getAll obtiene todos los usuarios
func (h *handler) getAll(w http.ResponseWriter, r *http.Request) {
	users, err := h.service.GetAllUsers()
	if err != nil {
{{- if .UseHelpers}}
		h.logger.Error("Failed to get users", "error", err)
		helpers.RespondError(w, err, http.StatusInternalServerError)
{{- else}}
		http.Error(w, "Error obteniendo usuarios", http.StatusInternalServerError)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	helpers.RespondSuccess(w, map[string]interface{}{
		"users": users,
		"count": len(users),
	}, "Usuarios obtenidos exitosamente")
{{- else}}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"data":    users,
		"count":   len(users),
		"status":  "success",
		"message": "Usuarios obtenidos exitosamente",
	})
{{- end}}
}

// getByID obtiene un usuario por ID
func (h *handler) getByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
{{- if .UseHelpers}}
		helpers.RespondError(w, helpers.ErrBadRequest, http.StatusBadRequest)
{{- else}}
		http.Error(w, "ID de usuario inválido", http.StatusBadRequest)
{{- end}}
		return
	}

	user, err := h.service.GetUserByID(id)
	if err != nil {
		if err == ErrUserNotFound {
{{- if .UseHelpers}}
			helpers.RespondError(w, helpers.ErrNotFound, http.StatusNotFound)
{{- else}}
			http.Error(w, "Usuario no encontrado", http.StatusNotFound)
{{- end}}
			return
		}
{{- if .UseHelpers}}
		helpers.RespondError(w, err, http.StatusInternalServerError)
{{- else}}
		http.Error(w, "Error obteniendo usuario", http.StatusInternalServerError)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	helpers.RespondSuccess(w, user, "Usuario obtenido exitosamente")
{{- else}}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"data":    user,
		"status":  "success",
		"message": "Usuario obtenido exitosamente",
	})
{{- end}}
}

// create crea un nuevo usuario
func (h *handler) create(w http.ResponseWriter, r *http.Request) {
	var dto CreateUserDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
{{- if .UseHelpers}}
		helpers.RespondError(w, helpers.ErrBadRequest, http.StatusBadRequest)
{{- else}}
		http.Error(w, "Datos de entrada inválidos", http.StatusBadRequest)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	// Validar DTO usando helpers
	if errors := helpers.ValidateStruct(dto); len(errors) > 0 {
		helpers.RespondJSON(w, map[string]interface{}{
			"status": "error",
			"errors": errors,
		}, http.StatusBadRequest)
		return
	}
{{- else}}

	// Validar DTO
	if err := dto.Validate(); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
{{- end}}

	user, err := h.service.CreateUser(dto)
	if err != nil {
		if err == ErrUserAlreadyExists {
{{- if .UseHelpers}}
			helpers.RespondError(w, err, http.StatusConflict)
{{- else}}
			http.Error(w, err.Error(), http.StatusConflict)
{{- end}}
			return
		}
{{- if .UseHelpers}}
		h.logger.Error("Failed to create user", "error", err)
		helpers.RespondError(w, err, http.StatusInternalServerError)
{{- else}}
		http.Error(w, "Error creando usuario", http.StatusInternalServerError)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	helpers.RespondCreated(w, user, "Usuario creado exitosamente")
{{- else}}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"data":    user,
		"status":  "success",
		"message": "Usuario creado exitosamente",
	})
{{- end}}
}

// update actualiza un usuario existente
func (h *handler) update(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
{{- if .UseHelpers}}
		helpers.RespondError(w, helpers.ErrBadRequest, http.StatusBadRequest)
{{- else}}
		http.Error(w, "ID de usuario inválido", http.StatusBadRequest)
{{- end}}
		return
	}

	var dto UpdateUserDTO
	if err := json.NewDecoder(r.Body).Decode(&dto); err != nil {
{{- if .UseHelpers}}
		helpers.RespondError(w, helpers.ErrBadRequest, http.StatusBadRequest)
{{- else}}
		http.Error(w, "Datos de entrada inválidos", http.StatusBadRequest)
{{- end}}
		return
	}

	user, err := h.service.UpdateUser(id, dto)
	if err != nil {
		if err == ErrUserNotFound {
{{- if .UseHelpers}}
			helpers.RespondError(w, helpers.ErrNotFound, http.StatusNotFound)
{{- else}}
			http.Error(w, "Usuario no encontrado", http.StatusNotFound)
{{- end}}
			return
		}
{{- if .UseHelpers}}
		helpers.RespondError(w, err, http.StatusInternalServerError)
{{- else}}
		http.Error(w, "Error actualizando usuario", http.StatusInternalServerError)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	helpers.RespondSuccess(w, user, "Usuario actualizado exitosamente")
{{- else}}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"data":    user,
		"status":  "success",
		"message": "Usuario actualizado exitosamente",
	})
{{- end}}
}

// delete elimina un usuario
func (h *handler) delete(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
{{- if .UseHelpers}}
		helpers.RespondError(w, helpers.ErrBadRequest, http.StatusBadRequest)
{{- else}}
		http.Error(w, "ID de usuario inválido", http.StatusBadRequest)
{{- end}}
		return
	}

	if err := h.service.DeleteUser(id); err != nil {
		if err == ErrUserNotFound {
{{- if .UseHelpers}}
			helpers.RespondError(w, helpers.ErrNotFound, http.StatusNotFound)
{{- else}}
			http.Error(w, "Usuario no encontrado", http.StatusNotFound)
{{- end}}
			return
		}
{{- if .UseHelpers}}
		helpers.RespondError(w, err, http.StatusInternalServerError)
{{- else}}
		http.Error(w, "Error eliminando usuario", http.StatusInternalServerError)
{{- end}}
		return
	}
{{- if .UseHelpers}}

	helpers.RespondSuccess(w, nil, "Usuario eliminado exitosamente")
{{- else}}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":  "success",
		"message": "Usuario eliminado exitosamente",
	})
{{- end}}
}
